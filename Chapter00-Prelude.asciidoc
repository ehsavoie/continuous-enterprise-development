== Prelude

_« La simplicité est la sophistication suprême.» - Léonard De Vinci_

Le développement de logiciel pour le web moderne continue à évoluer à très grande vitesse. Ces dernières années nous avons vu l'état du client migrer vers le serveur avant de revenir en arrière. Malgré les services rendu par JavaScript, deux ingénieurs donneront probablement trois avis différents sur ses mérites. L'arrivée d'HTML5 s'accompagne du support d'une armada de contenus riches et de la concurrence directement dans le navigateur. Le modèle de données relationnel, valide depuis plus de quarante ans, n'est plus à la mode remplacé par les systèmes NoSQL pleins de morgue. Nos systèmes de gestion de configuration ont été remanié en profondeur tant du point de vue de l'implémentation que du paradigme.

Nos outils deviennent des prescriptions pour un buffet en perpétuel changement, choisir parmi cette montagne de possibilités est un exercice vertigineux.

In the meantime, engineers face the same central challenges raised by building any multi-user program; we like our code elegant and maintainable.  We need it to run efficiently and securely.  We must assert its correctness.

In the Java space, many answers have come from a set of specifications released under the heading of the _Java Enterprise Edition_.  The overarching goal of this effort remains: hide away the syntactic complexity inherent in software development, and attempt to provide a clean standard model upon which to build.  In other words, the Java EE Platform composes an evolving toolkit, and a fallible one at that.

So a few years back we set out to fill some of the holes left unspecified by Java EE, and ended up holding the reins to a test framework which inspired our imaginations and proved more versatile than initially envisioned.  In fleshing out ideas to best share the lessons we'd learned, it became clear that we didn't need to document any particular technology.  Developers have been missing a cohesive map to navigate the murky waters of Java EE, its adjacent frameworks, and its services.

This text does not detail a singular specification.  Those volumes may be found elsewhere, because we've found it makes little sense to begin our learning with the Solutions.

Instead, let's align our start with the Problems.  We'll take a use-case centric approach to the testable development of enterprise Java, and after a bit of exploratory theory and requisite background each chapter will tackle a single high-level issue.  The solutions we propose may span from the user interface to persistent storage, touching upon a number of standards or third-party projects along the way.  All examples are executable, and as proof run in production on the companion website.

The newbie should expect to meet the players in an enterprise Java system, and bring a blank repository from scratch to a fully-deployed, live public application on the cloud.  Coders of all stripes may find appealing approaches to testing against seed data, pushing events to the client, interacting with a distributed data grid, validating the user interface, and more.

Quite simply, we'll aim to make the complicated much less so.  With luck, this will empower greater productivity and enjoyment in your work.

At least, that's been our experience while employing the techniques which inspired this book.