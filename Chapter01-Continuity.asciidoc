== Continuité

_"Lorsque nous marchons tous en symbiose et sommes concentrés sur le même objectif, le succès prend l’envol tout seul." - Henry Ford_

=== The Zen of Prevention

Parfois, il nous semble que tout l'univers conspire machiavéliquement pour détruire notre travail. Et jusqu'à un certain point c'est vrai : la nature a horreur de l'ordre. Cette entropie se manifeste de plusizeurs façons. Nous ouvrons une connexion réseau et un routeur tombe en panne. Nous écrivons un fichier sur un disque et le disque est plein. Nous oublions de vérifier la validité des entrées d'un programme et il explose inopinément.

Les causes d'un échec potentiel sont infinies et inévitables. En tant que garants de la qualité de notre code, nous avons à notre disposition deux tactiques de combat : être _réactif_ et être _pro-actif_.

==== Gestion réactive des erreurs

Appellée communément "faire le pompier", être réactif nous demande d'agir. Dans la plupart des cas, une situation indésirable est déjà en place et nous sommes chargés de corriger :

. La cause initale de l'erreur, si elle est sous notre contrôle.
. Les zones sans protection de notre code qui ont laissé cette cause faire autant de dégats.
. Les traces laissées par cette erreur dérrière elle.

Quiconque ayant parcouru les journaux binaires d'une base de données afin de remettre les données dans un état consistent peut témoigner du stress et de la perte de temps produits par la gestion en urgence des situations dues à une erreur inateendue dans l'exécution. Gérer les erreurs au fur et à mesure qu'elles arrivent implique une notion d'urgence : les activités d'une journée de travail normale sont mises entre parenthèse pour traiter des problèmes plus pressants.

Clairement, le mode réactif n'est pas notre meilleure option, et il doit donc être évité autant que faire se peut.

==== Les politiques pro-actives de qualité

"VOUS seuls pouvez éviter ... les incendies" est l'appel du United States Forest Service depuis 1947, soulignant ainsi l'importance de limiter les facteurs de risques d'un désastre _avant_ qu'il n'arrive.

Cette prévention des erreurs est liée au problème du _confinement_.  En cas d'erreur, nous voudrions le savoir dès que possible et traiter le problème avant qu'il n'impacte les autres parties dus système où il pourrait créer beaucoup plus de dégats.  Considérons ce simple morceau de code :

[source,java]
----
public String welcome(String name) {
  return "Hello, " + name;
}
----

Supposons qu'un utilisateur passe accidentellement +null+ à la méthode +welcome(String)+ ci-dessus.  La +String+ renvoyée serait alors :

+Hello, null+

Tout cela parce que les http://docs.oracle.com/javase/specs/jls/se7/html/[_Specifications du Langage Java Version 7_] précisent dans http://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.18.1[le paragraphe 15.18.1] que la concaténation avec une seule +String+ comme opérande résultera en la conversion en String de l'autre opérande.  Le pointeur +null+ est donc représenté sous la forme de la +String+ "null" selon les règles définies par http://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.1.11[le paragraphe 5.1.11].

Assurément ce n'est pas le résultat que nous attendions, mais nous nous sommes mis nous mêmes dans cette situation car nous n'avons pas _codé de manière défensive_ .  Améliorer la méthode +welcome(String)+ pour réaliser une _vérification préconditionnelle_ lèverait une +Exception+ à l'utilisateur et ainsi bloquerait l'exécution normale de la suite :

[source,java]
----
public String welcome(String name) {
  if (name == null || name.isEmpty()) {
    throw new IllegalArgumentException("name must be specified");
  }
  return "Hello, " + name;
}
----

Cette politique de _défaillance rapide_ est aussi importante durant l'exécution que pendant le développement.  Savoir comment limiter notre exposition aux erreurs reste un vaste sujet de recherche et de raffinement.  Heureusement, l'étude du _process de développement logiciel_ nous fournit un certain nombre de modèles sur lesquels nous pouvons fonder nos pratiques.

=== Process de développement logiciel

_Méthodologie.  Doctrine.  Paradigme._  Quelque soit le nom que nous lui donnaons, notre process (ou son absence ! ) est le script que nous suivons au jour le jour et qui guide notre approche pour réaliser un logiciel.  Typiquement inspirés des principaux thèmes auxquels nous croyons, un modèle de workflow de développement peut devenir un puissant outil pour éviter à vous et votre équipe de suivre des routes improductives. De nombreuses approches bien documentées existent, et connaitre les motivations qui sont derrière elles peut vous aider à choisir le 'bon' modèle pour votre projet.

==== Modèles séquentiels

Un processus _séquentiel_ ou _en série_ suit un chemin linéaire depuis la naissance du projet jusqu'à son achèvement. Au fur et à mesure que chaque étape du cycle de vie du développement s'achève, la suivante commence. On en revient pas en général sur les étapes passées, et on visualise souvent ce modèle sous la forme d'une suite de marches :

*** INSERT IMAGE ***

Le développement passe une étape après l'autre, suivant ce que l'on appelle le "cycle en V", souvent associé aux modèles séquentiels. Appelé aussi "Débuter par une grande étape de conception", ce processus dépend fortement d'une compréhension complète de l'ensemble des exigences du projet dès le début. La théorie derrière le modèle en V pourrait être résumée en "mesurer deux fois, coupr en une seule fois". En évaluant tous les éléments pouvant bouger, le but est d'essayer de réduire les pertes de temps en évitant de revenir en arrière pour corriger. De notre point de vue, cela est adapté aux projets sur un cycle de développement long visant une seule version.
Si ce modèle peut se fondre dans le moule du logiciel de détail, l'idée de ne jamais revenir en arrière à la base du processus séquentiel rend cette approche particulièrement fragile lorsqu'il faut écrire du code adaptable, ce modèle ne supporte pas la modifications des exigences. Pour cela il vaut mieux regarder des modèles à accès direct où il est possible de repasser par chacune des étapes de développement (voir de traiter plusieurs étapes en parallèle !).

==== Modèles itératifs

A l'opposé du workflow linéaire proposé par le cycle en V existe un ensemble de modèles itératifs bien connus construits pour faciliter le changement et promouvoir la parallélisation. En découpant un problème en petits composants plus facilement gérables, nous permettons de résoudre chaque sous élément indépendamment. De plus nous pouvons aussi opter pour une approche grossière lors de notre première passe, affinant notre solution au fur et à mesure des cycles de développement; c'est de là d'ailleurs que les modèles "itératifs" tirent leur nom.

===== Extreme Programming

Aussi connu sous le nom "XP", l'_Extreme Programming_ est une discipline qui introduit une boucle de retro-action à chaque étape du processus de développment. Une pratique devenue populaire plus particulièrement à la fin des années 90 et aux débuts des années 2000, XP accorde une grande importance à la communication et aux autres aspects sociaux.  Son workflow peut prendre la forme suivante :

*** INSERT IMAGE ***

Si le raisonnment complet qui a produit XP est décrit en détails dans le livre _Extreme Programming Explained: Embrace Change (Second Edition)_ de by Kent Beck, on peut résumer les idées principalesainsi :

* Des cycles de développement courts
* Des réunions quotidiennes brèves
* Pair Programming, responsabilisation et apropriation par l'équipe
* Faire tout ce qu'il est nécessaire de faire mais reporter à plus tard tout ce qui n'est pas essentiel
* Recueillir les retours de tous les participants, pas seulement les développeurs, tôt et fréquemment
* Développement piloté par les tests
** L'approche consitant à commencer par écrire des test automatisés puis de corriger / écrire le code principal jusqu'à ce qu'ils passent

En fait, XP comme d'autres modèles est à la fois une source d'inspiration et une mise en œuvre d'un ensemble plus grand de méthodes itératives telles qu'elles sont définies dans http://agilemanifesto.org/[_Manifesto for Agile Software Development_].

=== Tester _c'est_ développer

_"Move testing from the caboose to the engine." - Tim Ottinger, Senior Consultant, Industrial Logic_ 

Quelle que soit la méthode de développement prescrite par votre équipe et quelque soit votre adhésion à ses principes, au final vous allez devoir vérifier que votre code fonctionne. Bien sûr vous pourriez faire cela manuellement en déployant l'application et en laissant un humain suivre un plan de test, mais dès que cela est possible, il est beaucoup plus efficace et sûr d'automatiser l'exécution des tests. Donc vous allez devoir écrire des tests.

Mais nous pensons que tester ce n'est pas simplement vérifier que votre code fonctionne comme vous l'attendez.

Quand vous écrivez des tests vous devenez un _utilisateur_ de votre API. Vous verrez combien son utilisation est intuitive. Vous découvrirez des manques dans la documentation. Vous pouvez même découvrir qu'elle est trop verbeuse ou affreuse, et encore plus important : vous pouvez ré-évaluer votre conception avant qu'il ne soit trop tard. Vous vous mettez à la place de votre audience.

De plus, si vous écrivez vos tests en même temps que vous développez la logique métier, il se peut que vous trouviez votre travail plus _agréable_.  Vous saurez quand une exigence est terminée; vous aurez la satisfaction d'avoir des retours concrets en temps réel. Les avocats du _Développement Piloté par les Tests_ vont jusqu'à écrire les tests _avant_ le code lui même. De part notre expérience, l'écriture des tests peut être faite durant la construction du code initial ce qui permet à chaque partie d'influer sur l'autre.

Les tests automatisés peuvent avoir différentes formes, nous allons catégoriser certaines d'entre elles par la suite.text.

=== Les niveaux de test

Les tenants des méthodes de développement orientées test trient les tests selon plusieurs catégories :

* Acceptance
** Vérifie que le code correpond aux exigences métier
* Boite noire
** Vérifie qu'une API fonctionne selon le contrat sans se préoccuper de ce qu'il se passe à l'intérieur
* Compatibilité
** Vérifie que le code se comporte bien avec un ou plusieurs composants externes. Par exempleune application web doit s'afficher correctement sur Internet Explorer, Chrome, Firefox, Safari et les mobiles.
* Fonctionnel
** Vérifie que le code correspond aux exigences techniques qui découlent des exigences métier; ie. que toute les *fonctions* se comportent comme attendu
* Charge / Stress / Performance
** Vérifie et mesure comment un système traite les entrées sous charge, et comment il se dérade avec l'augmentation du traffic
* Regression
** Vérifie que les erreurs découvertes précédemment ont bien été corrigées ou que les fonctionnalités exitantes sont toujours utilisables
* Fumigatoire
** Un sous-ensemble de tous les cas de tests, prévus pouir s'exécuter rapidement et s'assurer que les principales fonctions d'un système fonctionnent correctement, sans se préoccuper des détails fins
* Boite blanche
** Vérifie qu'une API fonctionne selon le contrat en prenant en compte les spécificités internes en termes de structures de données et de constructions.

Une application bien testée peut avoir des tests couvrant plusieurs des catégories précédentes, et nous pouvons organiser ces types selon leur portée.

==== Unitaire

Le but d'un test unitaire est de valider qu'une unique fonctionnalité se comporte tel qu'attendu en isolation. Les tests unitaires sont caractérisés comme rapides, simplees, faciles à exécuter et fins. Ils peuvent creuser dans les détails d'implémentation pour un usage en mode _boite  blanche_.

Par exemple, chaque objet java hérite de la méthode +Object.hashCode()+ et de la méthode de tests d'égalité par valeur +Object.equals(Object)+.  Par contrat d'API, les appels à la méthode +hashCode+ et à l'égalité par valeur d'un objet doivent retourner le même résultat :

[source,java]
----
/**
 * Test du point 2 du contrat de la méthode hashCode défini par:
 * http://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#hashCode()
*/
public void testHashCodeOfEqualObjects() {
  // Declare some vars that are equal-by-value
  MyObject a = new MyObject("a");
  MyObject b = new MyObject("a");

  // Now ensure hashCode is working for these objects as contracted
  assert a.equals(b) : "The objects should be equal by value";
  assert a.hashCode() == b.hashCode() : "Hash codes of equal objects not equal";
}
----

Le test ci-dessus, réalisé avec le mot-clef Java +assert+, est un exemple classique d'un test unitaire. Il vérifie l'_invariant_ le plus petit possible (dans ce cas que les implementations de +equals()+ et de +hashCode()+ par +MyObject+ fonctionnent correctement l'une par rapport à l'autre).  De nombreux experts recommanderont de n'avoir qu'une assertion par test unitaire. De par notre expérience c'est une règle fantastique mais comme l'exemple ci-dessus li'illustre bien, utiliser votre bon sens. Si plusieurs assertions sont nécessaires pour conclure que tous les participants d'un invariant sont dans l'état attendu, utilisez ce qu'il faut.
Dans le cas où le test unitaire nécessite des entrées provenant d'autres composants, l'usage de _mock_ est une solution courante. Les mocks fournissent une implémentation alternative utilisée dans les tests afin de permettre au développeur de :

* Simuler une condition d'erreur
* Eviter de démarrer un processus couteux ou une longue pile d'exécution
* Eviter de dépendre de systèmes tiers qui pourraient ne pas être très fiables (voir disponibles)pour exécuter des tests
* Eviter de dépendre d'un mécanisme qui fournirait des valeurs non-reproductibles.
** Par exemple un générateur de nombres aléatoires se basant sur l'heure courante.

Si les mocks ont toute leur place dans l'arsenal du testeur, dans le contexte du développement d'entreprise nous pensons que leur usage doit être limité. Java Enterprise Edition est basé sur un modèle à composants _POJO_ (Plain Old Java Object) ce qui nous permet d'instancier directement des Servlets, EJBs et beans CDI. Cela est très pratique pour valider la logique métirevia des appels simples. Cependant la vraie puissance de Java EE se trouve dans le _couplage faible_ entre les composants, or les mocks ne simulent pas bien comment le conteneur lie ces différentes pièces .  Pour tester complètement une application vous devez tester l pile d'exécution complète et pas uniquement votre code. Pour cela vous avez besoin d'une solution plus complète que ce que permettent les tests unitaires.

==== Intégration

Imaginez que nous souhaitions poser un tuyau pour faire passer de l'eau depuis un réservoir jusu'à une station d'épuration.  Les tests unitaires que nous avons décrits ci-dessus correspondrait au fait de vérifier que chacune des sections de tuyau est de bonne qualité et ne fuit pas.  Mais le tout est supérieur à la somme des parties : l'eau peut toujours s'échapper entre les sections.

Il en est de même avec le logiciel. Nous devons nous assurer que les composants s'intègrent bien les uns avec les autres. Cela est particulièrement vrai pour Java EE où l' _injection de dépendance_ est présente à tous les niveaux. C'est super de ne pas avoir un bean explicitement lié à un autre, mais au bout du compte nous dépendons d'un conteneur pour créer ces liens pour nous. Si nos métadonnées ou notre configuration sont incorrectes alors nos points d'injection peuvent ne pas être remplis comme nous l'attendons.  Cela peut produire des erreurs lors du déploiement ou pire ce qui nous impose d'avoir une couverture de test pour les intéractions entre les composants.

Lorsque nous parlons de _tests d'intégration_ dans ce livre c'est dans le contexte d'un _conteneur_. Historiquement les intéractions avec un serveur d'application étaient notoiremment difficiles à tester. Pour cette raison, Java EE est devenu un gros mot pour beaucoup. C'est le but de ce texte que de clairement décrire les techniques pour construire des applications d'entreprise testables.  Alors que beaucoup peuvent voir cette discussion comme traitant des tests d'intégration, au contraire nous pensons qu'il s'agit plutôt de *développement* et que les tests d'intégration sont un bonus de cette équation.

D'un certain coté, les tests _font partie_ du développement.

=== Bases des frameworks de test

Comme vous pouvez l'imaginer, les _services du conteneur_ nous aident véritablement à réduire la complexité du code de notre application.  L'injection de dépendance nous libère de la création manuelle des liesn entre les composants, et des fonctionnalités comme la _sécurité déclarative_ et la _gestion des transactions_ nous permettent de ne pas avoir à mélanger ces problèmatiques techniques à notre code métier.  Cependant, rien n'est gratuit; le coût de l'aide apportée par un framework ou un serveur d'application est que nous avons ajouté un nouveau point d'intégration.  Et chaque point d'intégration doit être validé par un test d'intégration.

Java supporte nativement les erreurs de type +java.lang.Assertion+ et le mot-clef +assert+ qui peuvent s'avérer des outils bien pratiques lorsqu'ils sont utilisés à bon escient.  Car les assertions utilisant +assert+ ne sont traitées que lorsque l'option +-ea+ est présente sur la commande de démaarage de la JVM. Vous n'avez donc pas à vous préoccuper de l'impact sur les performances des ces vérifications supplémentaires dans un environnement de productionlorsque cette fonction n'est pas activée. Pour cette raison cela a du sens d'utiliser +assert+ pour tester du code interne, par exemple :

[source,java]
----
private String welcome(String name) {
  assert name!=null && !name.isEmpty() : "name must be specified";
  return "Hello, " + name;
}
----

Ce code ayant la visibilité +private+, nous n'avons pas à nous préoccuper de la vérification pré-conditionnelles des entrées de l'utilisateur; le paramètre +username+ est fourni par du code que _nous_ avons écrit.  Et donc ce code ne doit pas être testé en production.

Bien sûr, les assertions peuvent nous aider mais il ne s'agit pas de *tests*.  Les tests suivent un chemin d'exécution du code et valident une ou plusieurs _post-conditions_.  Par exemple nous pourrions écrire le code client suivant pour vérifier que la méthode +welcome(String)+ de la section _Politiques proactives de qualité_ se comporte comme nous l'attendons :

[source,java]
----
public class WelcomeJDKTest {

  /** WelcomeBean instance to be tested **/
  private WelcomeBean welcomer;

  private WelcomeJDKTest(WelcomeBean welcomer) {
    this.welcomer = welcomer;
  }

  public static void main(String... args) {

    /** Make a test client, then execute its tests **/
    WelcomeJDKTest tester = new WelcomeJDKTest(new WelcomeBean());
    tester.testWelcome();
    tester.testWelcomeRequiresInput();

  }

  private void testWelcome() {
    String name = "ALR";
    String expectedResult = "Hello, " + name;
    String receivedResult = welcomer.welcome(name);
    if(!expectedResult.equals(receivedResult)) {
      throw new AssertionError("Did not welcome " + name + " correctly");
    }
  }

  private void testWelcomeRequiresInput() {
    boolean gotExpectedException = false;
    try {
      welcomer.welcome(null);
    } catch (final IllegalArgumentException iae) {
      gotExpectedException = true;
    }
    if(!gotExpectedException) {
      throw new AssertionError("Should not accept null input");
    }
  }

}
----

Pas terrible en termes de couverture de code; nous nous sommes assurés que la méthode +welcome+ fonctionne comme attendu et nous avons même vérifier qu'elle rejette l'entrée +null+ au bon endroit, avant qu'il ne puisse rendre les choses plus compliquées par la suite.

Mais le rapport signal sur bruit est très mauvais lorsque nous devons écrire nos propres clients de test avec la méthode +main(String[])+.  Regardez tout le code inintéressant que nous avons du écrire pour exécuter les tests par rapport au code de test en lui-même ! Comme nous utilisons frameworks et modèles à composants pour éliminer les octects redondants et inutiles de notre logique métier, nous pouvons profiter de bibliothèques populaires pour alléger nos tests.

==== JUnit

Le framework de test http://www.junit.org/[JUnit] Test l'un des frameworks de test les plus connus pour Java. Initiallement porté depuis le travail de http://en.wikipedia.org/wiki/Kent_Beck[Kent Beck] pour tester le langage de programmation Smalltalk, JUnit est l'artéfact le plus téléchargé depuis le dépôt http://search.maven.org/[Maven Central Repository] en dehors des bibliothèques utilisées pour exécuter Maven lui même (en Août 2012).

Si nous reprenons notre code +WelcomeJDKTest+ ci-dessus en utilisant JUnit nous pourrions obtenir quelquechose de proche de ceci :

[source,java]
----
public class WelcomeJUnitTest {

    /** To be set by the {@link Before} lifecycle method **/
    private WelcomeBean welcomer;

    /** Called by JUnit before each {@link Test} method **/
    @Before
    public void makeWelcomer() {
        this.welcomer = new WelcomeBean();
    }

    @Test
    public void welcome() {
        final String name = "ALR";
        final String expectedResult = "Hello, " + name;
        final String receivedResult = welcomer.welcome(name);
        Assert.assertEquals("Did not welcome " + name + " correctly", expectedResult, receivedResult);
    }

    @Test
    public void welcomeRequiresInput() {
        boolean gotExpectedException = false;
        try {
            welcomer.welcome(null);
        } catch (final IllegalArgumentException iae) {
            gotExpectedException = true;
        }
        Assert.assertTrue("Should not accept null input", gotExpectedException);
    }
}
----

Le premier bénéfice que nous obtenons est que nous n'avons plus besoin d'une méthode +main(String[])+ et nous n'avons plus besoin d'appeler manuellement nos méthodes de test.  En effet, JUnit exécutera consciencieusement tout cycle de vie (ie. +@Before+) ou les méthodes (annotés avec +@Test+) de test et rapportera les résultats à son exécuteur initial.  Deuxièmement, nous avons accès à la bibliothèque JUnit, par exemple un ensemble de méthodes utilitaires dans +org.junit.Assert+, pour nous aider à réduire la quantité de code nécessaire pour écrire nos assertions.

JUnit est aussi très bien supporté par les IDE, rendant l'exécution des tests durant le développement beaucoup plus facile.  Par exemple, regardez le menu contextuel disponible dans Eclipse :

image:images/ch01-continuity/runas_junit.png["JUnit IDE Runner Integration"]

A l'opposé de notre client test +main(String[])+ fait main, JUnit produit des rapports.  Dans l'IDE ils peuvent être rendus graphiquement :

image:images/ch01-continuity/junit_test_execution.png["JUnit IDE Reporting Integration"]

Souvent nous ferons usage d'un _serveur d'intégration continue_ pour gérer nos builds et fournir une vue de l'audit du code au cours du temps.   Durant ce processus de build plus formel, les résultats peuvent être produits sous la forme d'un fichier XML qui peut ête analysé par des plugins.  Cela peut être pratique pour suivre l'évolution du nombre de tests et du nombre de tests en échec', comme par exemple sur http://jenkins-ci.org/[Serveur d'Intégration Continue] :

image:images/ch01-continuity/ci_test_trend.png["Continuous Integration Test Reporting"]

Bien sûr, JUnit n'est pas le seul framework de test sur la place.

==== TestNG

Si JUnit incarne la simplicité pour les tests en Java, http://testng.org/doc/index.html[TestNG] vante une plus grande flexibilité pour les développeurs en offrant un plus grand ensemble de fonctionnalités.  Cependant discuter les différences entre ces deux frameworks est au delà du cadre de ce livre, et les concepts sous jacents restent très proches.  La réécriture de notre test avec TestNG devrait vous paraitre familière :

[source,java]
----
public class WelcomeTestNGTest {

    /** To be set by the {@link @BeforeTest} lifecycle method **/
    private WelcomeBean welcomer;

    /** Called by TestNG before each {@link Test} method **/
    @BeforeTest
    public void makeWelcomer() {
        this.welcomer = new WelcomeBean();
    }

    @Test
    public void welcome() {
        /// .. Omitting logic for brevity
        Assert.assertEquals(receivedResult, expectedResult, "Did not welcome " + name + " correctly");
    }

    @Test
    public void welcomeRequiresInput() {
        /// .. Omitting logic for brevity
        Assert.assertTrue(gotExpectedException, "Should not accept null input");
    }
}
----

L'ordre de certains paramètres et les noms des annotations de l'API ont changés mais le concept reste : écrire moins de code et laisser le framework gérer la pile d'appel.

L'intégration avec les IDE existe même si elle n'est pas fournie avec Eclipse Juno, reste http://testng.org/doc/download.html[relativement simple à installer] et fournit un exécuteur graphique comme celui que nous avons vu avec JUnit:

image:images/ch01-continuity/testng_test_execution.png["TestNG IDE Runner Integration"]

=== Développement continu

Les partisans de l'Extreme Programming et des méthodologies Agile doivent connaitre l' http://martinfowler.com/articles/continuousIntegration.html[Intégration Continue], une pratique qui défend une évolution rapide du code source de la branche de développement pour détecter les erreurs au fur et à mesure qu'elles sont introduites. Une telle approche implique :

* Un dépôt de code source de référence (ce qui n'est pas *opposé* aux systèmes de gestion de configuration décentralisés, comme nous le verrons bientôt)
* Une suite de tests complète
* Un système de build automatisé
* Un déploiement automatisé

Ces règles générales sont applicables pour la plupart des langages modernes, elles ne sont pas liées à des outils et sont largement acceptées par la communauté du développement.

Donc, pourquoi le titre de _Développement continu_ pour ce livre ?

En plus de l'idéologie et de la théorie adoptées par la communauté Agile, nous regarderons des outils et des projets concrets à la fois dans et en dehors de la plateforme Java EE pour mieux adresser les préoccupations réelles du développeur Java d'entreprise.

Le dépôt Git de référence contenant le livr et le code source de l'application exemple est hébergé par nos amis de http://www.github.com[GitHub] à l'adresse https://github.com/arquillian/continuous-enterprise-development[https://github.com/arquillian/continuous-enterprise-development].  Le site compagnong de ce livre est situé à l'adresse http://continuousdev.org[http://continuousdev.org] et le compte Twitter officiel est http://twitter.com/ContinuousDev[@ContinuousDev].  Les auteurs peuvent être contactés via l'adresse email authors@continuousdev.org.

Tous les contenus du dépôt de ce livre sont sous la licence http://creativecommons.org/licenses/by-sa/2.0/['Creative Commons Attribution-ShareAlike 2.0 Generic'], a et nous invitons la communauté à contribuer soit par des demandes d'évolution, la correction des erreurs typographiques et des améliorations via notre https://github.com/arquillian/continuous-enterprise-development/issues[gestionnaire de bugs].

La version papier de ce livre et des exemples correspond au tag +1.0.0+ dans le dépôt Git de référnce, et le développement se poursuivre dans la branche +master+ pour corriger les erreurs et ajouter des matériaux supplémentaires, nouveaux chapitres et cas d'utilisation.  La communauté est encouragée pour sggérer ou demander le traitement de nouveaux sujets.

L'application exemple qui accompagne les cas d'utilisation traités par ce livre s'appelle GeekSeek et est publiquement disponible à l'adresse http://geekseek.continuousdev.org[http://geekseek.continuousdev.org].  Le code source est disponible dans ce dépôt dans le dossier +code/application+ et les instructions pour la construire, la tester et l'exécuter localement sont définies dans https://github.com/arquillian/continuous-enterprise-development/blob/master/Chapter04-RequirementsAndExampleApplication.asciidoc[Chapitre 4].  Les taches de build de l'application sont gentillement exécutées par http://www.cloudbees.com[CloudBees] aux adresses https://arquillian.ci.cloudbees.com/job/GeekSeek-wildfly/[https://arquillian.ci.cloudbees.com/job/GeekSeek-wildfly/] et https://arquillian.ci.cloudbees.com/job/GeekSeek-jbosseap/[https://arquillian.ci.cloudbees.com/job/GeekSeek-jbosseap/].

Nous encourageons toutes vos contributions et nous espérons que vous touverez le matériel traité ici intéressant et que vous en tirerez bénéfice dans votre travail et votre carrière dans le développement d'entreprise testable.

La première étape est de rencontrer les principaux acteurs qui vont constituer ce livre.
